{"name":"smartassert","tagline":"Useful assertion utilities based on Hamcrest and Google Guava's Predicates","body":"# SmartAsserts [![Build Status](https://travis-ci.org/smarttested/smartassert.svg?branch=master)](https://travis-ci.org/smarttested/smartassert)\r\n\r\n*SmartAsserts* is a set of utils which is used to provide the simplest way to perform 'hard' and 'soft' (delayed) assertions.\r\n\r\n## Guidline:\r\n 1. [Maven Dependency](#maven-dependency) \r\n 2. **[HOW TO (As simple as it is possible)](#how-to)**\r\n 3. [Hard Assertions](#hard-assertions)\r\n 4. [Soft Assertions](#soft-assertions)\r\n 5. [TestNG integration](#testng-integration)\r\n 6. [Predicates and Predefined Validators](#predicates-and-predefined-validators)\r\n\r\n## Maven Dependency\r\n\r\nLast version:\r\n```xml\r\n<dependency>\r\n    <groupId>com.smarttested</groupId>\r\n    <artifactId>smartassert</artifactId>\r\n    <version>1.0.0</version>\r\n</dependency>\r\n```\r\n\r\n## HOW-TO\r\n```java\r\n/* Put annotation to let TestNG know you gonna use SmartAssert */\r\n@Listeners(SoftValidationMethodListener.class)\r\npublic class YourUnitTest\r\n{\r\n\r\n\r\n   @Test\r\n   public void testYourBusinessLogic()\r\n   {\r\n      /* Add validation of logic you wonna check */\r\n      \r\n      SmartAssert.expect(Lists.newArrayList(\"one\", \"two\"), CoreMatchers.hasItem(\"three\"), \"There is no 'three'!\")\r\n      \t.assertSoft();\r\n      SmartAssert.expect(true, CoreMatchers.is(false), \"True is not false!\").assertSoft();\r\n      \r\n      /* add another validations you need. First one won't fail this test */\r\n      System.out.println(\"Validations failed, but test still works!\")\r\n   }\r\n   \r\n   /* Enjoy! Once test is finished, it will fail with all failed validations it had! */\r\n}\r\n```\r\n\r\n## Hard Assertions\r\nHard assertions is basically assertions you always used before. For example, \r\n\r\n```java\r\norg.testng.Assert.assertTrue(false);\r\n```\r\n\r\nLet's assume we have some BigDecimal object and need to validate several fields:\r\n\r\n```java\r\nBigDecimal decimal = BigDecimal.valueOf(-0.05);\r\n\r\n/* check value is positive. Provided value is negative, so we've got error assertion here */\r\nAssert.assertEquals(\"Positive value is expected!\", 1, decimal.signum());\r\n\r\n/* check value has scale == 1. Provided value's scale is '2', so we've got error assertion here */\r\nAssert.assertEquals(\"Incorrect decimal scale!\", 1, decimal.scale());\r\n```\r\n\r\nIn this case test will fail on first assertion once provided object is not positive, but after test you don't know whether test object has right scale! Another words, **second assert is not performed**. To solve this issue you might do something like:\r\n\r\n```java\r\nBigDecimal decimal = BigDecimal.valueOf(-0.05);\r\nStringBuilder errors = new StringBuilder();\r\n\r\n/* check value is positive. Provided value is negative, so we've got error assertion here */\r\nif (1 != decimal.signum()){\r\n   errors.append(\"Positive value is expected!\");\r\n}\r\n\r\n/* check value has scale == 1. Provided value's scale is '2', so we've got error assertion here */\r\nif (1 != decimal.scale()){\r\n   errors.append(\"Incorrect decimal scale!\");\r\n}\r\n\r\nAssert.assertTrue(errors.toString(), 0 == errors.length());\r\n```\r\nThis is not perfect way to solve issue obviously :) \r\n\r\nSo, problem described above is actually what [Soft Assertions](#soft-assertions) are doing for you.\r\n\r\n## Soft Assertions\r\n\r\nLet's try to re-write example above in soft-assert style:\r\n\r\n```java\r\nBigDecimal decimal = BigDecimal.valueOf(-0.05);\r\n\r\n/* check value is positive. Provided value is negative, but we haven't got error */\r\nSmartAssert.expect(decimal.signum(), CoreMatchers.is(1), \"Positive value is expected!\").assertSoft();\r\n\r\n/* check value has scale == 1. Provided value's scale is '2', so we haven't got error assertion here */\r\nSmartAssert.expect(decimal.scale(), CoreMatchers.is(1), \"Incorrect decimal scale!\").assertSoft();\r\n\r\n/* Here is place were real assertion will be thrown */\r\nSmartAssert.validateSoftAsserts();\r\n```\r\n\r\nUsing smartassert you are able to write assertions in junit/testNG style, but perform real validation on demand (basically, at the end of the method). All failures will be accumulated into one:\r\n```\r\ncom.smarttested.qa.smartassert.SoftAssertException: The following assert has been failed:  \r\nPositive value is expected!  \r\nExpected: is <1>  \r\n     but: was <-1>  \r\nIncorrect decimal scale!  \r\nExpected: is <1>  \r\n     but: was <2>  \r\n\tat com.smarttested.qa.smartassert.SoftFailuresHolder.getException(SoftFailuresHolder.java:62)  \r\n\tat com.smarttested.qa.smartassert.SoftFailuresHolder.validate(SoftFailuresHolder.java:52)  \r\n\tat com.smarttested.qa.smartassert.SmartAssert.validateSoftAsserts(SmartAssert.java:134)  \r\n\tat com.smarttested.qa.smartassert.SoftAssertTest.testBigDecimal(SoftAssertTest.java:27)  \r\n```\r\n\r\n\r\nActually, there is a still way to use hard asserts:\r\n```java\r\nSmartAssert.expect(true, Predicates.alwaysFalse(), \"I'm an error!\").assertHard();\r\n```\r\nor\r\n```java\r\nSmartAssert.expect(true, Predicates.alwaysFalse(), \"I'm an error!\").assertHard(SomeYourCustomException.class);\r\n```\r\nif you wonna some custom exception to be raised here. \r\n\r\n\r\n## TestNG Integration\r\nTo avoid calling \r\n```java\r\nSmartAssert.validateSoftAsserts();\r\n```\r\nwe provided TestNG listener which will do that on each test method. Another words, if some test has some failures, they will be validated after methed/test execution. \r\n```java\r\n@Listeners(SoftValidationMethodListener.class)\r\npublic class SoftValidationMethodListenerTest {\r\n\r\n    @Test\r\n    public void testGuavaSoft() {\r\n        SmartAssert.expect(true, Predicates.alwaysFalse(), \"I'm an error!\").assertSoft();\r\n        SmartAssert.expect(true, Predicates.alwaysFalse(), \"it's ok\").assertSoft();\r\n        SmartAssert.expect(true, Predicates.alwaysFalse(), \"I'm an second error!\").assertSoft();\r\n    }\r\n}\r\n```\r\nThis method fails with description of all three failed validations. \r\nSometimes you need to write negative test which expects some error. SoftValidationMethodListener support default TestNG behavior so this test pass, because expected exception is specified in TestNG annotation:\r\n```java\r\n@Listeners(SoftValidationMethodListener.class)\r\npublic class SoftValidationMethodListenerTest {\r\n\r\n    @Test(expectedExceptions = {SoftAssertException.class, SkipException.class})\r\n    public void testGuavaSoft() {\r\n        SmartAssert.expect(true, Predicates.alwaysFalse(), \"I'm an error!\").assertSoft();\r\n        SmartAssert.expect(true, Predicates.alwaysFalse(), \"it's ok\").assertSoft();\r\n        SmartAssert.expect(true, Predicates.alwaysFalse(), \"I'm an second error!\").assertSoft();\r\n    }\r\n}\r\n```\r\n\r\n## Predicates and Predefined Validators\r\nA very good style of writing unit and functional tests is to prepare validators you need and do not duplicate them in each test. There is a two ways to do that. First, you can use built-in Hamcrest validators:\r\n```java\r\nSmartAssert.expect(\"hello world\", CoreMatchers.containsString(\"hello\"), \"This validation is passing\").assertSoft();\r\n```\r\nHamcrest has a lot of validators which may cover almost all your needs. Of course, you can prepare your own validators by implementing Hamcrest's ```org.hamcrest.Matcher``` interface. More information you can find [here](https://code.google.com/p/hamcrest/) \r\n\r\nAnother way to perform validation and making matchers is [Guava's Predicates](https://code.google.com/p/guava-libraries/wiki/FunctionalExplained#Predicates)\r\n\r\nLet's consider the following example:\r\n```java\r\n@Listeners(SoftValidationMethodListener.class)\r\npublic class SoftAssertTest {\r\n\r\n    public static final Predicate<String> STRING_IN_UPPER_CASE = new Predicate<String>() {\r\n        @Override\r\n        public boolean apply(String input) {\r\n            /* validates all symbols in string are whitespaces or upper-case symbols */\r\n            return CharMatcher.JAVA_UPPER_CASE.or(CharMatcher.WHITESPACE).matchesAllOf(input);\r\n        }\r\n\r\n        /* add toString just to have pretty error message if validator fail on this predicate */\r\n        @Override\r\n        public String toString() {\r\n            return \"Upper case validator\";\r\n        }\r\n    };\r\n\r\n    @Test\r\n    public void testUpperCase() {\r\n        /* this gonna fail */\r\n        SmartAssert.expect(\"lower case\", STRING_IN_UPPER_CASE, \"String is not in upper case\").assertSoft();\r\n\r\n        /* this gonna pass */\r\n        SmartAssert.expect(\"UPPER CASE\", STRING_IN_UPPER_CASE, \"String is not in upper case\").assertSoft();\r\n    }\r\n}\r\n```\r\n\r\nSo, by creating your own matchers and predicates you can move your validation logic into separate logic layer and use across all project. You might also want to use this stuff via some dependency injection container (like Guice or Spring) and replace your validators depending on some conditions:\r\n\r\n```java\r\n    \r\n    /* you can have multiple implementations. For example, first one\r\n     * can validate only upper case symbols, second one can pass\r\n     * validation with digits and whitespaces, because they do not\r\n     * have case at all. \r\n     */\r\n    @Inject\r\n    @Named(\"upperCaseValidator\")\r\n    private Predicate<String> upperCaseValidator;\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}